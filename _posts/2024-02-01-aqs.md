---
title: "AQS——抽象队列同步器"
categories:
  - 八股
  - 并发
tags:
  - AQS——抽象队列同步器
---

# AQS——抽象队列同步器

AQS 就是一个抽象类，主要用来构建锁和同步器。



```java
public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer implements java.io.Serializable {
}
```

AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 `ReentrantLock`，`Semaphore`，其他的诸如 `ReentrantReadWriteLock`，`SynchronousQueue`等等皆是基于 AQS 的。

## 核心思想

AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 **CLH 锁** （Craig, Landin, and Hagersten locks） 实现的。

>   CLH 锁是对自旋锁的一种改进，是一个**虚拟的双向队列**（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系），暂时获取不到锁的线程将被加入到该队列中。AQS 将每条请求共享资源的线程封装成一个 CLH 队列锁的一个结点（Node）来实现锁的分配。在 CLH 队列锁中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。
>
>   CLH 队列结构如下图所示：
>
>   ![CLH 队列结构](/assets/images/clh-queue-structure.png)
>
>   CLH 锁是对自旋锁的一种改进，有效的解决了以上的两个缺点。
>
>   1.   首先它将线程组织成一个队列，保证先请求的线程先获得锁，避免了饥饿问题。
>   2.   其次锁状态去中心化，让每个线程在不同的状态变量中自旋，这样当一个线程释放它的锁时，只能使其后续线程的高速缓存失效，缩小了影响范围，从而减少了 CPU 的开销。
>
>   CLH 锁数据结构很简单，类似一个链表队列，**<u>所有请求获取锁的线程会排列在链表队列中，自旋访问队列中前一个节点的状态</u>**。当上一个节点释放锁后，它将得到这个锁。
>
>   CLH 锁是一种隐式的链表队列，没有显式的维护前驱或后继指针。因为每个等待获取锁的线程只需要轮询前一个节点的状态就够了，而不需要遍历整个队列。在这种情况下，只需要使用一个局部变量保存前驱节点，而不需要显式的维护前驱或后继指针。
>
>   ### 那每个node不都还在自旋吗？
>
>   在AQS队列中，每个节点确实会在一定程度上自旋等待前一个节点的状态。但是，这种自旋等待与普通的自旋有所不同，主要体现在以下几个方面：
>
>   1.  **自旋条件**：AQS队列中的自旋是基于某些条件的，通常是等待前一个节点的状态发生变化。而普通的自旋可能是简单地在循环中重复执行一些操作，而不考虑特定的条件。
>   2.  **自旋时机**：在AQS队列中，节点的自旋通常发生在入队操作时或者节点状态发生变化时。而普通的自旋可能发生在任何需要等待某个条件满足的场景中。
>   3.  **自旋退出机制**：AQS队列中的自旋通常会在满足一定条件时退出，例如成功获取锁或者超时。而普通的自旋可能没有特定的退出条件，需要依赖外部因素来终止自旋。

![img](/assets/images/CLH.png)

AQS 使用 **int 成员变量 `state` 表示同步状态**，通过内置的 **线程等待队列** 来完成获取资源线程的排队工作。

`state` 变量由 `volatile` 修饰，用于展示当前临界资源的获锁情况。

```java
// 共享变量，使用volatile修饰保证线程可见性
private volatile int state;
```

以 `ReentrantLock` 为例，`state` 初始值为 0，表示未锁定状态。A 线程 `lock()` 时，会调用 `tryAcquire()` 独占该锁并将 `state+1` 。此后，其他线程再 `tryAcquire()` 时就会失败，直到 A 线程 `unlock()` 到 `state=`0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（`state` 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。

## Semaphore

`synchronized` 和 `ReentrantLock` 都是一次只允许一个线程访问某个资源，而`Semaphore`(信号量)可以用来控制同时访问特定资源的线程数量。

Semaphore 的使用简单，我们这里假设有 N(N>5) 个线程来获取 `Semaphore` 中的共享资源，下面的代码表示同一时刻 N 个线程中只有 5 个线程能获取到共享资源，其他线程都会阻塞，只有获取到共享资源的线程才能执行。等到有线程释放了共享资源，其他阻塞的线程才能获取到。

```java
// 初始共享资源数量
final Semaphore semaphore = new Semaphore(5);
// 获取1个许可
semaphore.acquire();
// 释放1个许可
semaphore.release();
```

当初始的资源个数为 1 的时候，`Semaphore` 退化为排他锁。

## CountDownLatch

`CountDownLatch` 允许 `count` 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。

`CountDownLatch` 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 `CountDownLatch` 使用完毕后，它不能再次被使用。

读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。

为此我们定义了一个线程池和 count 为 6 的`CountDownLatch`对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用`CountDownLatch`对象的 `await()`方法，直到所有文件读取完之后，才会接着执行后面的逻辑。

### CountDownLatch和Semaphore不同点：

1.  **用途不同**：CountDownLatch主要用于实现等待其他线程执行完毕再执行的场景，而Semaphore主要用于控制同时访问某个资源的线程数量。
2.  **计数器操作方式不同**：CountDownLatch的计数器只能减少，初始化时设置一个初始值，每次调用countDown()方法计数器减1；Semaphore的计数器可以增加也可以减少，初始化时设置一个最大值，每次调用acquire()方法使计数器减1，每次调用release()方法使计数器加1。
3.  **获取许可机制**：Semaphore基于获取和释放许可来控制线程的数量，当没有许可时，线程需要等待；而CountDownLatch基于计数器的方式，当计数器为0时，所有等待的线程都被唤醒。
4.  **可重复使用性**：Semaphore的许可是可以被释放和重新获取的，可以重复使用；而CountDownLatch的计数器一旦减为0，就无法重新设置或重置。









