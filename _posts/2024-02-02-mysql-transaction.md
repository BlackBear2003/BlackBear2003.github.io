---
title: "MySQL 事务"
categories:
  - 八股
  - MySQL
tags:
  - 事务
  - MySQL
---

# 事务

## 事务ACID

1.  **原子性（Atomicity）**：指事务是一个不可分割的操作序列，要么全部执行成功，要么全部失败回滚。这意味着在事务中的所有操作要么全部完成，要么全部取消，不存在部分完成的情况。
2.  **一致性（Consistency）**：指事务执行前后，数据库**从一个一致的状态转换到另一个一致的状态**。这意味着事务执行前后数据库中的数据必须满足所有的约束条件，包括数据的完整性约束、唯一性约束等。
3.  **隔离性（Isolation）**：指并发执行的事务之间是相互隔离的，**一个事务的执行不会被其他事务所影响**。隔离性能够防止并发执行的事务相互干扰，避免数据不一致的情况发生。
4.  **持久性（Durability）**：指一旦事务提交，其所做的修改就会永久保存在数据库中，即使系统发生故障，这些修改也不会丢失。持久性确保了**数据的持久保存**，使得数据不会因为系统故障而丢失。

**MySQL 默认是隐式提交**，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。

InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？

-   持久性是通过 redo log （重做日志）来保证的；
-   原子性是通过 undo log（回滚日志） 来保证的；
-   隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
-   一致性则是通过持久性+原子性+隔离性来保证；

**多个事务并发执行时可能会遇到**

-   脏读：读到其他事务未提交的数据；
-   不可重复读：前后读取的数据不一致；
-   幻读：前后读取的记录数量不一致。

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

-   **读未提交（\*read uncommitted\*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
-   **读提交（\*read committed\*）**，指一个事务提交之后，它做的变更才能被其他事务看到；
-   **可重复读（\*repeatable read\*）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
-   **串行化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

按隔离水平高低排序如下：

![图片](/assets/images/cce766a69dea725cd8f19b90db2d0430.png)

![图片](/assets/images/4e98ea2e60923b969790898565b4d643.png)

**MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象**

解决的方案有两种：

-   针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
-   针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

## Read View

对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View**。

**可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View**。

**读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View**。

这两个隔离级别实现是通过「**事务的 Read View 里的字段**」和「**记录中的两个隐藏列**」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。









