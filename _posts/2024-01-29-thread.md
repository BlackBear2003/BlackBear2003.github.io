---
title: "最常见也最复杂的——Thread"
categories:
  - 八股
  - 并发
tags:
  - 最常见也最复杂的——Thread
---

# 最常见也最复杂的——Thread

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。

在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。

JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。

>   线程模型是用户线程和内核线程之间的关联方式，常见的线程模型有这三种：
>
>   1.  一对一（一个用户线程对应一个内核线程）
>   2.  多对一（多个用户线程映射到一个内核线程）
>   3.  多对多（多个用户线程映射到多个内核线程）
>
>   ![常见的三种线程模型](/assets/images/three-types-of-thread-models.png)
>
>   在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是**一个 Java 线程对应一个系统内核线程。**
>
>   ### 操作系统的线程种类
>
>   -   用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用），通过用户空间的线程库实现特定的调度算法和线程管理策略（比如C++的 pthread 库）。**操作系统无法感知和调度用户级线程**，因此如果一个用户级线程被阻塞，可能会导致整个进程被阻塞。
>
>       ` pthread `库创建的线程属于用户级线程，其管理和调度都由用户程序或线程库完成，而不需要操作系统内核的直接支持。这意味着用户可以根据实际需求实现特定的线程调度策略，例如优先级调度、轮转调度等，以满足程序的性能和实时性要求。
>
>       pthread 库创建的**线程仍然运行在操作系统提供的进程上下文中**，而**线程的调度和切换仍然受操作系统调度器的影响。**
>
>   -   内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。创建和销毁的开销比用户级线程大，而且操作系统的调度算法和策略对其影响更大。
>
>       **一个进程可以拥有多个内核级线程**。在多线程编程模型中，通常一个进程中的所有线程共享该进程的地址空间和资源，但是它们拥有**独立的执行上下文**。**这些线程可以并行地在多个 CPU 核心上执行**，从而提高了程序的并发性和性能。
>
>   用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。
>
>   # 为什么用户线程必须映射到内核线程？
>
>   ![img](/assets/images/c7857f61f7b6432dbd914a8bb5a90983~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp.png)
>
>   作为内核的一部分，调度器只知道内核级的线程，因为如前所述，内核不知道用户线程的存在，因为它们是在创建进程的地址空间中创建的，因此内核对它们没有控制权。
>
>   内核中的CPU调度程序只是在其拥有的线程 "列表 "中查看可供执行的线程列表，并开始调度它们。
>
>   一个进程所创建的所有用户线程都在指定给整个进程的同一个内核级线程上执行。每当轮到指定的进程在CPU上执行时，它的内核线程就会被安排到CPU上，从而执行该进程。
>
>   用户线程需要被映射到内核线程，因为是内核将线程安排到CPU上执行，为此它必须知道它所安排的线程。对于一个简单的进程来说，内核只知道这个进程的存在，而不知道在这个进程中创建的用户线程，所以内核只会把这个进程的线程安排到CPU上，所有在这个进程中的其他用户线程如果要被执行，就必须一个一个地映射到指定给创建进程的内核线程。

### Java 内存区域

![Java 运行时数据区域（JDK1.8 之后）](/assets/images/java-runtime-data-areas-jdk1.8.png)

#### 虚拟机栈和本地方法栈为什么是私有的?

**虚拟机栈：** 每个 Java 方法在执行之前会创建一个**<u>栈帧</u>**用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

**本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <u>Native 方法服务</u>。** **在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。**

-   为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

#### 堆和方法区

堆和方法区是所有线程共享的资源，其中**堆是进程中最大的一块内存**，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### Java线程的状态

![Java 线程状态变迁图](/assets/images/640.png)

-   NEW: 初始状态，线程被创建出来但没有被调用 `start()` 。
-   RUNNABLE: 运行状态，线程被调用了`start()`等待运行的状态。
-   BLOCKED：阻塞状态，需要等待锁释放。(锁被其它线程占有，这个时候线程就会进入 **BLOCKED（阻塞）** 状态。)
-   WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
-   TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
-   TERMINATED：终止状态，表示该线程已经运行完毕。

![RUNNABLE-VS-RUNNING](/assets/images/RUNNABLE-VS-RUNNING.png)

在 JVM 层面，只能看到 RUNNABLE 状态

### 什么是线程上下文切换?

线程在执行过程中会有自己的运行条件和状态，当出现如下情况的时候，线程会从占用 CPU 状态中退出。

-   主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
-   时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
-   调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
-   被终止或结束运行

线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。

### 死锁的四个必要条件

1.  互斥条件：该资源任意一个时刻只由一个线程占用。
2.  请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3.  不剥夺条件: 线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4.  循环等待条件: 若干线程之间形成一种头尾相接的循环等待资源关系。

### sleep() 方法和 wait() 方法对比

**共同点**：两者都可以暂停线程的执行。

**区别**：

-   **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
-   `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
-   `wait()` 方法被调用后**，线程不会自动苏醒，**需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
-   `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法。为什么这样设计呢？下一个问题就会聊到。

`wait()` 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁。











